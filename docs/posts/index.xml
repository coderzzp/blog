<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on zzp的博客</title>
    <link>https://coderzzp.github.io/blog/posts/</link>
    <description>Recent content in Posts on zzp的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Feb 2021 14:03:32 +0800</lastBuildDate><atom:link href="https://coderzzp.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>8102年了，你还是只会npm</title>
      <link>https://coderzzp.github.io/blog/posts/8102%E5%B9%B4%E4%BA%86%E4%BD%A0%E8%BF%98%E6%98%AF%E5%8F%AA%E4%BC%9Anpm/</link>
      <pubDate>Tue, 23 Feb 2021 14:03:32 +0800</pubDate>
      
      <guid>https://coderzzp.github.io/blog/posts/8102%E5%B9%B4%E4%BA%86%E4%BD%A0%E8%BF%98%E6%98%AF%E5%8F%AA%E4%BC%9Anpm/</guid>
      <description>写在前面 npm是每个现代的前端工程师都应该掌握的包管理工具，但是我们大多数时间都只是在git clone -&amp;gt;npm install -&amp;gt;npm start 三连，我自己也是在遇到一些坑之后才去解到npm背后的规则
当我们在npm install的时候，我们在install什么 废话，当然是包了，包简而言之是我们工程项目中所依赖的由广大开发者所提供的一个函数，或者一个类等等。
一个npm 包最少需要一个package.json文件，这个文件会用来描述这个包的名称（在npm仓库中唯一），用途，版本，依赖包等等，官方当然不会让你手写这个文件啦，npm内置了npm init 这个方法
mkdir my-package &amp;amp;&amp;amp; cd my-package npm init 如果暂时不care这些东西，可以使用npm init &amp;ndash;yes 快速生成全部填写默认值的包
mkdir my-package &amp;amp;&amp;amp; cd my-package npm init --yes 这是我生成的package.json文件，注意到main这个字段了吗，这个字段描述的是 这个包的入口文件，假如你想对外输出一个函数，可以新建一个main.js并通过module.exports 导出 //main.js module.exports=function(){ console.log(&amp;#39;真香!&amp;#39;) } 发布之前我们还需要了解npm的版本管理机制：semver规范，semver 约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本号.小版本号.修订版本号
 MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号 MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号 PATCH 对应修订版本号，一般针对修复 BUG 的版本号  ok，在了解了这些之后，我们可以开始发布了，注意npm 要求在 publish 之前，必须更新版本号 ，你可以选择手动更新版本号，也可以使用npm自带的命令npm version major|minor|patch来更新版本。 一切准备就绪之后，使用npm publish来发布我们的包
npm install npm install 有两种使用方式，一种是不带参数npm install，它会下载当前工程的所有依赖包到本地node_modules目录下，另一种是npm install xxx，表示我要给这个工程新增一个包依赖。npm install之后我们会在node_modules这个文件下找到所有我们下载的依赖包，然后在项目中requrie这个包即可使用。</description>
    </item>
    
    <item>
      <title>服务端缓存策略之node实践</title>
      <link>https://coderzzp.github.io/blog/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B9%8Bnode%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Tue, 23 Feb 2021 14:02:36 +0800</pubDate>
      
      <guid>https://coderzzp.github.io/blog/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B9%8Bnode%E5%AE%9E%E8%B7%B5/</guid>
      <description>浏览器缓存策略之node实战 浏览器缓存是web开发中减少服务器压力相当常见也是相当有效的一种方式，那么本文会总结浏览器缓存的主要策略，并且最后会给出一个带缓存的node服务器代码实践。
浏览器缓存策略讲解 以下讲解全部基于服务器端支持缓存策略，若不支持，则每次都会想服务端发起请求，即不存在缓存 第一次访问某个网站的时候： 浏览器会缓存这个响应的所有信息
之后再次访问这个网站的时候：会判断是否命中强缓存（根据expiress和cache-control），如果命中强缓存，会直接读取之前缓存过的资源，如果未命中强缓存，那么执行弱缓存策略，回头看一下我们之前缓存过的请求头中，Etag和Last-modified两个字段，我们的浏览器会将这两个缓存过的头放在请求头中，但是这个时候Etag变成了If-none-match，Last-modified变成了If-modified-since，服务器收到请求后会根据这两个字段判断请求的资源是否新鲜（即是否有改动），如果新鲜，返回304，如果不新鲜，则获取新资源，返回200. 浏览器把缓存类型根据是否需要向服务器发起请求分为两种：强缓存和弱缓存（协商缓存）
   缓存类型 获取资源方式 状态码 是否发送请求到服务器     强缓存 从缓存取 200(from disk cache) 否，直接从缓存取   弱缓存 从缓存去取 304(not modified) 是，通过服务器来告诉浏览器缓存是否可用     强缓存详解  expires，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源 cache-control：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：   no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
  no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
  public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。
  private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。
 ps：如果cache-control与expires同时存在的话，cache-control的优先级高于expires      弱缓存详解 弱缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。
 Last-Modified/If-Modified-Since  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header 浏览器收到304的响应后，就会从缓存中加载资源 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值   Etag/If-None-Match：这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。  Etag相对Last-modified的区别   一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；</description>
    </item>
    
    <item>
      <title>从0实现一个webpack</title>
      <link>https://coderzzp.github.io/blog/posts/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebpack/</link>
      <pubDate>Tue, 23 Feb 2021 14:01:45 +0800</pubDate>
      
      <guid>https://coderzzp.github.io/blog/posts/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebpack/</guid>
      <description>从0实现一个webpack 什么是webpack？ WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（jsx，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。如果你不了解webpack的用法，可以转到阮一峰的webpack教程先学习一下webpack的用法。
webpack最简单的用法 git clone https://github.com/coderzzp/how2-learn-nodejs.git cd how2-learn-nodejs cd webpack-demo 这是一个最简单的webpac的例子，可以简单看一下文件目录，之后继续执行
npm i npm run dev 命令行出现 即打包完成。 看到目录下多了一个dist文件，里面有一个bundle文件，这其实就是在执行npm run dev即package.json脚本中的webpack命令，此时我们打开页面
open index.html 页面输出hello world~，显然页面里的./dist/bundle.js就是以index.js为入口文件打包后的文件
bundle.js是怎么打包index.js+words.js的呢？ 我们打开dist/bundle.js来看一下,虽然只有100行的代码一眼看过去因为各种注释的关系显得很乱，但是仔细看一下整个代码结构实际上是一个自执行函数，直接传入一个对象即mudules.
(function(modules) { })({ &amp;#34;./index.js&amp;#34;: function(...){...}, &amp;#34;./words.js&amp;#34;: function(...){...} }) 而这里的modules正是我们需要打包的文件对象，类似
{ &amp;#34;文件位置&amp;#34;：函数， &amp;#34;文件位置&amp;#34;：函数 } 那么我们再来看看自执行函数内部是如何使用mudules这个对象的，首先看这个函数的返回值是：
return __webpack_require__(__webpack_require__.s = &amp;#34;./index.js&amp;#34;); 接着看_webpack_require__这个最核心的函数：
/******/ //缓存对象 /******/ var installedModules = {}; /******/ // 定义require函数 /******/ function __webpack_require__(moduleId) { /******/ /******/ // 如果缓存对象中有，即取出返回值 /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].</description>
    </item>
    
    <item>
      <title>服务端缓存之redis入门</title>
      <link>https://coderzzp.github.io/blog/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B9%8Bredis%E5%85%A5%E9%97%A8/</link>
      <pubDate>Tue, 23 Feb 2021 13:43:23 +0800</pubDate>
      
      <guid>https://coderzzp.github.io/blog/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B9%8Bredis%E5%85%A5%E9%97%A8/</guid>
      <description>content  为什么使用服务端缓存 什么是redis redis相对memcache的优势 过期策略 内存淘汰机制 缓存更新策略 缓存穿透 &amp;amp; 缓存雪崩 是否需要redis  引言 起因：我们在做配置平台的时候，需要用node提供下发服务，而redis是我们在项目中使用的一项缓存技术，今天将知识点整理了分享给大家
1.为什么使用服务端缓存  更快
 在日常对数据库的访问中，读操作的次数远超写操作，所以需要读的可能性是比写的可能大得多的。当我们使用SQL语句去数据库进行读写操作时，数据库就会去磁盘把对应的数据索引取回来，这是一个相对较慢的过程。
而服务端缓存因为通常都是放在内存中的，相比放在硬盘中的sql数据，它的速度要快的多，如果让请求去访问缓存中的数据，接口就会更快
 更高并发
 如图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。而缓存能够承受的请求量是远远大于直接访问数据库的，如果让缓存承担绝大部分的请求，系统就能承受更大的并发量
2.什么是redis redis即为我们刚才所说的服务端缓存的一种
 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API
 有什么特点？  内存数据库
 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速
 单线程
 单线程就意味着它不需要处理线程间的通信问题，不需要频繁的切换上下文 传统意义下的多进程并发处理：如果一个I/O流进来，我们就开启一个进程处理这个I/O流。但是我们刚才说了：redis是单线程的， 那么他是如何处理多并发的场景呢？
 采用io多路复用模型
 IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，系统首先将需要进行IO操作的socket添加到select中，然后select会帮我们监听每个注册的io流的状态。当有数据到达时，对应的socket被激活，用户线程读取数据并且继续执行
 以上三点决定了redis是非常快的，官方数据redis的读速度达到了11w/s，写速度达到8w/s
 3.redis相对于memcache的优势  支持快照和持久化
 memcache是市面上另一个比较主流的key-value缓存数据库，memcache也是将数据存在内存当中的，但是它有一个问题，一旦它的服务器重启或者宕机，所有的数据都会消失，因为内存中的数据无法持久化；而redis与之相比的优势之一就是，它支持数据的快照和持久化。也就是说即使他的服务器在重启之后，也可以通过在硬盘中的rdb快照文件，实现数据恢复
 支持master-slave主从复制
 第二点，memcache如果说他的服务挂掉了，所有请求会瞬间涌向数据库，可能会导致数据库的宕机，而redis因为支持master-slave主从复制，当主节点出现问题时，可以有子节点提供服务，实现快速的故障恢复。并且redis的主从模式可以实现读写分离，由主节点提供写服务，子节点提供读服务，可以大大提高redis服务器的并发量  支持更加丰富的数据类型
  string:它是最常见的一种数据类型，redis可以完全实现memcache的功能，并且它还提供了额外的一些操作，例如:获取字符串长度，往字符串append内容 等等一些操作 Hash：在memcaceh中，因为只支持string存储，所以对于结构化的信息例如用户信息，即使需要更改某一个属性的数据，也需要在存入的时候对整个用户信息执行一次序列化操作，而取出的时候进行一次反序列化操作，相当于js中的Json.stringfy和json.parse，这样对于性能来说是非常不友好的。而redis天然支持hash结构，即我们每次可以只更新hash中的某一个属性 list： List就是链表，因为它是有序的，所以我们可以用来实现一些任务队列的功能 set：无序的非重复集合，类似于在微博中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能 Sorted set：有序的非重复集合，我们可以依靠它非常快速的实现一个类似于斗鱼 用户排行榜 的应用  4.</description>
    </item>
    
  </channel>
</rss>
