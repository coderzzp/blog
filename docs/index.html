<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>zzp的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="">
    <meta name="generator" content="Hugo 0.80.0" />
    
    
      <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">
    

    

  
  
    <link rel="stylesheet" href="/blog/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css" >
  




    
      

    

    
    
      <link href="/blog/index.xml" rel="alternate" type="application/rss+xml" title="zzp的博客" />
      <link href="/blog/index.xml" rel="feed" type="application/rss+xml" title="zzp的博客" />
      
    
    
    <meta property="og:title" content="zzp的博客" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://coderzzp.github.io/blog/" />
<meta property="og:updated_time" content="2021-02-23T14:03:32+08:00" />
<meta itemprop="name" content="zzp的博客">
<meta itemprop="description" content="">
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="zzp的博客"/>
<meta name="twitter:description" content=""/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/blog/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        zzp的博客
      
    </a>
    <div class="flex-l items-center">
      

      
      















    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          zzp的博客
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      

  <article class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray">
    
  </article>
  
  
  
  
  
  
  
    
    

    <div class="pa3 pa4-ns w-100 w-70-ns center">
      
       
          <h1 class="flex-none">
            Recent Posts
          </h1>
        

      

      <section class="w-100 mw8">
        
        
          <div class="relative w-100 mb4">
            
<article class="bb b--black-10">
  <div class="db pv4 ph3 ph0-l no-underline dark-gray">
    <div class="flex flex-column flex-row-ns">
      
      <div class="blah w-100">
        <h1 class="f3 fw1 athelas mt0 lh-title">
          <a href="https://coderzzp.github.io/blog/posts/8102%E5%B9%B4%E4%BA%86%E4%BD%A0%E8%BF%98%E6%98%AF%E5%8F%AA%E4%BC%9Anpm/" class="color-inherit dim link">
            8102年了，你还是只会npm
            </a>
        </h1>
        <div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
          写在前面 npm是每个现代的前端工程师都应该掌握的包管理工具，但是我们大多数时间都只是在git clone -&gt;npm install -&gt;npm start 三连，我自己也是在遇到一些坑之后才去解到npm背后的规则
当我们在npm install的时候，我们在install什么 废话，当然是包了，包简而言之是我们工程项目中所依赖的由广大开发者所提供的一个函数，或者一个类等等。
一个npm 包最少需要一个package.json文件，这个文件会用来描述这个包的名称（在npm仓库中唯一），用途，版本，依赖包等等，官方当然不会让你手写这个文件啦，npm内置了npm init 这个方法
mkdir my-package &amp;&amp; cd my-package npm init 如果暂时不care这些东西，可以使用npm init &ndash;yes 快速生成全部填写默认值的包
mkdir my-package &amp;&amp; cd my-package npm init --yes 这是我生成的package.json文件，注意到main这个字段了吗，这个字段描述的是 这个包的入口文件，假如你想对外输出一个函数，可以新建一个main.js并通过module.exports 导出 //main.js module.exports=function(){ console.log(&#39;真香!&#39;) } 发布之前我们还需要了解npm的版本管理机制：semver规范，semver 约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本号.小版本号.修订版本号
 MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号 MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号 PATCH 对应修订版本号，一般针对修复 BUG 的版本号  ok，在了解了这些之后，我们可以开始发布了，注意npm 要求在 publish 之前，必须更新版本号 ，你可以选择手动更新版本号，也可以使用npm自带的命令npm version major|minor|patch来更新版本。 一切准备就绪之后，使用npm publish来发布我们的包
npm install npm install 有两种使用方式，一种是不带参数npm install，它会下载当前工程的所有依赖包到本地node_modules目录下，另一种是npm install xxx，表示我要给这个工程新增一个包依赖。npm install之后我们会在node_modules这个文件下找到所有我们下载的依赖包，然后在项目中requrie这个包即可使用。
        </div>
          <a href="https://coderzzp.github.io/blog/posts/8102%E5%B9%B4%E4%BA%86%E4%BD%A0%E8%BF%98%E6%98%AF%E5%8F%AA%E4%BC%9Anpm/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
        
      </div>
    </div>
  </div>
</article>

          </div>
        
          <div class="relative w-100 mb4">
            
<article class="bb b--black-10">
  <div class="db pv4 ph3 ph0-l no-underline dark-gray">
    <div class="flex flex-column flex-row-ns">
      
      <div class="blah w-100">
        <h1 class="f3 fw1 athelas mt0 lh-title">
          <a href="https://coderzzp.github.io/blog/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B9%8Bnode%E5%AE%9E%E8%B7%B5/" class="color-inherit dim link">
            服务端缓存策略之node实践
            </a>
        </h1>
        <div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
          浏览器缓存策略之node实战 浏览器缓存是web开发中减少服务器压力相当常见也是相当有效的一种方式，那么本文会总结浏览器缓存的主要策略，并且最后会给出一个带缓存的node服务器代码实践。
浏览器缓存策略讲解 以下讲解全部基于服务器端支持缓存策略，若不支持，则每次都会想服务端发起请求，即不存在缓存 第一次访问某个网站的时候： 浏览器会缓存这个响应的所有信息
之后再次访问这个网站的时候：会判断是否命中强缓存（根据expiress和cache-control），如果命中强缓存，会直接读取之前缓存过的资源，如果未命中强缓存，那么执行弱缓存策略，回头看一下我们之前缓存过的请求头中，Etag和Last-modified两个字段，我们的浏览器会将这两个缓存过的头放在请求头中，但是这个时候Etag变成了If-none-match，Last-modified变成了If-modified-since，服务器收到请求后会根据这两个字段判断请求的资源是否新鲜（即是否有改动），如果新鲜，返回304，如果不新鲜，则获取新资源，返回200. 浏览器把缓存类型根据是否需要向服务器发起请求分为两种：强缓存和弱缓存（协商缓存）
   缓存类型 获取资源方式 状态码 是否发送请求到服务器     强缓存 从缓存取 200(from disk cache) 否，直接从缓存取   弱缓存 从缓存去取 304(not modified) 是，通过服务器来告诉浏览器缓存是否可用     强缓存详解  expires，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源 cache-control：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：   no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。
  no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。
  public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。
  private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。
 ps：如果cache-control与expires同时存在的话，cache-control的优先级高于expires      弱缓存详解 弱缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。
 Last-Modified/If-Modified-Since  浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header 浏览器收到304的响应后，就会从缓存中加载资源 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值   Etag/If-None-Match：这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。  Etag相对Last-modified的区别   一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
        </div>
          <a href="https://coderzzp.github.io/blog/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B9%8Bnode%E5%AE%9E%E8%B7%B5/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
        
      </div>
    </div>
  </div>
</article>

          </div>
        
          <div class="relative w-100 mb4">
            
<article class="bb b--black-10">
  <div class="db pv4 ph3 ph0-l no-underline dark-gray">
    <div class="flex flex-column flex-row-ns">
      
      <div class="blah w-100">
        <h1 class="f3 fw1 athelas mt0 lh-title">
          <a href="https://coderzzp.github.io/blog/posts/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebpack/" class="color-inherit dim link">
            从0实现一个webpack
            </a>
        </h1>
        <div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
          从0实现一个webpack 什么是webpack？ WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（jsx，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。如果你不了解webpack的用法，可以转到阮一峰的webpack教程先学习一下webpack的用法。
webpack最简单的用法 git clone https://github.com/coderzzp/how2-learn-nodejs.git cd how2-learn-nodejs cd webpack-demo 这是一个最简单的webpac的例子，可以简单看一下文件目录，之后继续执行
npm i npm run dev 命令行出现 即打包完成。 看到目录下多了一个dist文件，里面有一个bundle文件，这其实就是在执行npm run dev即package.json脚本中的webpack命令，此时我们打开页面
open index.html 页面输出hello world~，显然页面里的./dist/bundle.js就是以index.js为入口文件打包后的文件
bundle.js是怎么打包index.js+words.js的呢？ 我们打开dist/bundle.js来看一下,虽然只有100行的代码一眼看过去因为各种注释的关系显得很乱，但是仔细看一下整个代码结构实际上是一个自执行函数，直接传入一个对象即mudules.
(function(modules) { })({ &#34;./index.js&#34;: function(...){...}, &#34;./words.js&#34;: function(...){...} }) 而这里的modules正是我们需要打包的文件对象，类似
{ &#34;文件位置&#34;：函数， &#34;文件位置&#34;：函数 } 那么我们再来看看自执行函数内部是如何使用mudules这个对象的，首先看这个函数的返回值是：
return __webpack_require__(__webpack_require__.s = &#34;./index.js&#34;); 接着看_webpack_require__这个最核心的函数：
/******/ //缓存对象 /******/ var installedModules = {}; /******/ // 定义require函数 /******/ function __webpack_require__(moduleId) { /******/ /******/ // 如果缓存对象中有，即取出返回值 /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].
        </div>
          <a href="https://coderzzp.github.io/blog/posts/%E4%BB%8E0%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAwebpack/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
        
      </div>
    </div>
  </div>
</article>

          </div>
        
      </section>

      
      <section class="w-100">
        <h1 class="f3">More</h1>
        
        
          <h2 class="f5 fw4 mb4 dib mr3">
            <a href="https://coderzzp.github.io/blog/posts/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%93%E5%AD%98%E4%B9%8Bredis%E5%85%A5%E9%97%A8/" class="link black dim">
              服务端缓存之redis入门
            </a>
          </h2>
        

        
        
          <a href="https://coderzzp.github.io/blog/posts/" class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc">All Posts</a>
        
        </section>
      

      </div>
  

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://coderzzp.github.io/blog/" >
    &copy;  zzp的博客 2021 
  </a>
    <div>














</div>
  </div>
</footer>

  </body>
</html>
